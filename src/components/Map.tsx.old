import { useEffect, useRef, useState, useMemo, useCallback } from 'react';
import { GoogleMap, useJsApiLoader } from '@react-google-maps/api';
import { City, TimeRange, TrafficFlowPoint } from '../types';
import { SAMPLE_CULTURAL_SITES } from '../utils/data';
import { 
  fetchNearbyPlaces, 
  placesToHeatmapData, 
  fetchDataForTimeRange, 
  fetchPlaceDetails,
  generateTrafficFlowData,
  generateSimulatedTrafficFlow,
  createPolylinePathsFromPoints,
  getRouteColor,
  isRoutesApiAvailable,
  apiDiagnostics
} from '../utils/maps';
import { toast } from 'react-hot-toast';

// Update the libraries array to include routes if possible
// Note: "routes" isn't officially in the documented libraries but we can try to load it
const libraries = ["places", "visualization", "geometry"] as const;

const containerStyle = {
  width: '100%',
  height: '70vh'
};

const mapOptions = {
  disableDefaultUI: false,
  zoomControl: true,
  streetViewControl: false,
  mapTypeControl: true,
  fullscreenControl: true,
  clickableIcons: false, // Improve performance
  gestureHandling: 'cooperative',
};

interface MapProps {
  selectedCity: City;
  selectedTimeRange: TimeRange;
  currentTimestamp?: number; // Timestamp from the time slider
  shouldAnimateHeatmap?: boolean;
  onFlowPointsUpdate?: (points: TrafficFlowPoint[]) => void;
  onNearbyPlacesUpdate?: (places: any[]) => void;
}

// Add a version parameter to force reload if needed
const mapApiOptions = {
  id: 'google-map-script',
  googleMapsApiKey: process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY || '',
  libraries,
  version: "weekly", // Use the weekly version to ensure access to the latest features
  mapIds: [process.env.NEXT_PUBLIC_GOOGLE_MAPS_MAP_ID || ''],
  language: 'en',
};

const Map = ({ 
  selectedCity, 
  selectedTimeRange, 
  currentTimestamp,
  shouldAnimateHeatmap = false,
  onFlowPointsUpdate,
  onNearbyPlacesUpdate
}: MapProps) => {
  const { isLoaded, loadError } = useJsApiLoader(mapApiOptions);

  const [map, setMap] = useState<google.maps.Map | null>(null);
  const [heatmap, setHeatmap] = useState<google.maps.visualization.HeatmapLayer | null>(null);
  const [markers, setMarkers] = useState<google.maps.Marker[]>([]);
  const [isMapInitialized, setIsMapInitialized] = useState(false);
  const [showTimeRangeNotification, setShowTimeRangeNotification] = useState(false);
  const [notificationMessage, setNotificationMessage] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [flowPoints, setFlowPoints] = useState<TrafficFlowPoint[]>([]);
  const [flowMarkers, setFlowMarkers] = useState<google.maps.Marker[]>([]);
  const [isFlowAnimating, setIsFlowAnimating] = useState(false);
  const [visualizationMode, setVisualizationMode] = useState<'heatmap' | 'flow' | 'combined'>('combined');
  const [showDetailedStats, setShowDetailedStats] = useState(false);
  const [hoveredArea, setHoveredArea] = useState<{position: google.maps.LatLng, data: any} | null>(null);
  const zoomLevelRef = useRef<number>(12);
  
  const animationFrameRef = useRef<number | null>(null);
  const lastTimestampRef = useRef<number | null>(null);
  
  const mapRef = useRef<google.maps.Map | null>(null);
  const infoWindowRef = useRef<google.maps.InfoWindow | null>(null);
  const heatmapDataRef = useRef<google.maps.visualization.WeightedLocation[]>([]);
  const timeRangeDataCache = useRef<Record<string, google.maps.visualization.WeightedLocation[]>>({});
  const flowPathsRef = useRef<google.maps.Polyline[]>([]);
  const lastSuccessToastRef = useRef<number | null>(null);

  // Memoize map options to prevent unnecessary re-renders
  const mapOptionsMemo = useMemo(() => ({
    ...mapOptions,
    mapId: process.env.NEXT_PUBLIC_GOOGLE_MAPS_MAP_ID,
  }), []);

  // Helper function to find nearby flow points (for hover interactions)
  const findNearbyPoints = useCallback((position: google.maps.LatLng, points: TrafficFlowPoint[], radiusMeters: number) => {
    return points.filter(point => {
      const pointPos = new google.maps.LatLng(point.position.lat, point.position.lng);
      return google.maps.geometry.spherical.computeDistanceBetween(position, pointPos) <= radiusMeters;
    });
  }, []);
  
  // Helper function to calculate average speed of points
  const calculateAverageSpeed = useCallback((points: TrafficFlowPoint[]) => {
    if (points.length === 0) return 0;
    return points.reduce((sum, point) => sum + point.speed, 0) / points.length;
  }, []);
  
  // Helper function to calculate primary direction of flow
  const calculatePrimaryDirection = useCallback((points: TrafficFlowPoint[]) => {
    if (points.length === 0) return 'N/A';
    
    // Group bearings into 8 compass directions
    const directions: {[key: string]: number} = {
      'N': 0, 'NE': 0, 'E': 0, 'SE': 0, 
      'S': 0, 'SW': 0, 'W': 0, 'NW': 0
    };
    
    points.forEach(point => {
      const bearing = point.bearing;
      // Convert bearing to compass direction
      if (bearing >= 337.5 || bearing < 22.5) directions['N']++;
      else if (bearing >= 22.5 && bearing < 67.5) directions['NE']++;
      else if (bearing >= 67.5 && bearing < 112.5) directions['E']++;
      else if (bearing >= 112.5 && bearing < 157.5) directions['SE']++;
      else if (bearing >= 157.5 && bearing < 202.5) directions['S']++;
      else if (bearing >= 202.5 && bearing < 247.5) directions['SW']++;
      else if (bearing >= 247.5 && bearing < 292.5) directions['W']++;
      else if (bearing >= 292.5 && bearing < 337.5) directions['NW']++;
    });
    
    // Find the most common direction
    return Object.entries(directions).reduce((max, [dir, count]) => 
      count > max.count ? {dir, count} : max, {dir: 'N/A', count: 0}).dir;
  }, []);

  // Enhanced helper function to get color based on intensity
  const getIntensityColor = useCallback((intensity: number) => {
    // Normalize intensity between 0 and 1
    const normalized = Math.min(1, Math.max(0, (intensity - 0.5) / 1.5));
    
    // Blue (low) to Yellow (medium) to Red (high)
    if (normalized < 0.5) {
      // Blue to Yellow
      const r = Math.round(normalized * 2 * 255);
      const g = Math.round(normalized * 2 * 255);
      const b = Math.max(0, Math.round(255 - (normalized * 2 * 255)));
      return `rgb(${r}, ${g}, ${b})`;
    } else {
      // Yellow to Red
      const r = 255;
      const g = Math.round((1 - (normalized - 0.5) * 2) * 255);
      const b = 0;
      return `rgb(${r}, ${g}, ${b})`;
    }
  }, []);
  
  // Helper function to update heatmap from flow points - define this early since updateFlowVisualization depends on it
  const updateHeatmapFromFlowPoints = useCallback((points: TrafficFlowPoint[]) => {
    if (!map) return;
    
    // Convert flow points to weighted locations for heatmap
    const heatmapData: google.maps.visualization.WeightedLocation[] = points.map(point => ({
      location: new google.maps.LatLng(point.position.lat, point.position.lng),
      weight: point.intensity || 1 // Use intensity for weight if available
    }));
    
    // Create or update heatmap
    if (heatmap) {
      heatmap.setData(heatmapData);
      
      // Only show heatmap in heatmap or combined mode
      heatmap.setMap(visualizationMode === 'heatmap' || visualizationMode === 'combined' ? map : null);
    } else {
      const newHeatmap = new google.maps.visualization.HeatmapLayer({
        data: heatmapData,
        map: visualizationMode === 'heatmap' || visualizationMode === 'combined' ? map : null,
        radius: 20,
        opacity: 0.7,
        gradient: [
          'rgba(0, 255, 0, 0)',
          'rgba(0, 255, 0, 1)',
          'rgba(255, 255, 0, 1)',
          'rgba(255, 125, 0, 1)',
          'rgba(255, 0, 0, 1)'
        ]
      });
      setHeatmap(newHeatmap);
    }
  }, [map, heatmap, visualizationMode]);
  
  // Enhanced animation function for smoother particle flow
  const animateFlowPoints = useCallback((timestamp: number, skipFactor = 4) => {
    if (!map) return;
    
    // Initialize last timestamp if not set
    if (lastTimestampRef.current === null) {
      lastTimestampRef.current = timestamp;
    }
    
    // Calculate time delta
    const delta = timestamp - (lastTimestampRef.current || 0);
    lastTimestampRef.current = timestamp;
    
    // Update progress of each flow point
    setFlowPoints(prevPoints => {
      return prevPoints.map(point => {
        // Calculate new progress with smoother, speed-based movement
        const progressIncrement = (delta / 1000) * (point.speed / 30); // Adjusted for better visual flow
        let newProgress = point.progress + progressIncrement;
        
        // Reset progress when reaching the end
        if (newProgress >= 1) {
          newProgress = 0;
        }
        
        return {
          ...point,
          progress: newProgress
        };
      });
    });
    
    // Update markers based on new flow point positions
    const newMarkers: google.maps.Marker[] = [];
    
    // Only show markers in flow or combined mode
    if (visualizationMode === 'flow' || visualizationMode === 'combined') {
      // Remove old markers
      flowMarkers.forEach(marker => marker.setMap(null));
      
      // Create new markers based on updated flow points
      // Calculate actual skip factor based on point density and zoom level
      const dynamicSkipFactor = Math.max(1, Math.min(skipFactor, Math.floor(flowPoints.length / 500)));
      
      flowPoints.forEach((point, index) => {
        // Only show a subset of markers based on skipFactor
        if (index % dynamicSkipFactor === 0) {
          // Calculate current position based on progress
          const lat = point.position.lat + (point.nextPosition.lat - point.position.lat) * point.progress;
          const lng = point.position.lng + (point.nextPosition.lng - point.position.lng) * point.progress;
          
          // Get color based on intensity
          const color = getIntensityColor(point.intensity || 1);
          
          // Scale marker size based on intensity
          const scale = 2 + Math.min(3, point.intensity || 1);
          
          // Create marker
          const marker = new google.maps.Marker({
            position: { lat, lng },
            map,
            icon: {
              path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
              scale: scale,
              fillColor: color,
              fillOpacity: 0.8,
              strokeWeight: 1,
              strokeColor: '#FFFFFF',
              rotation: point.bearing // Orient marker in direction of travel
            },
            optimized: true,
            visible: true
          });
          
          // Add hover info to marker
          const speedDisplay = (point.speed * 20).toFixed(1);
          const intensityPercent = Math.round((point.intensity || 1) * 50);
          
          // Create info window content
          const content = `
            <div style="padding: 8px; max-width: 200px;">
              <div style="font-weight: bold; margin-bottom: 5px;">Traffic Flow Details</div>
              <div>Speed: ${speedDisplay} km/h</div>
              <div>Crowd Density: ${intensityPercent}%</div>
              <div>Direction: ${getBearingAsDirection(point.bearing)}</div>
            </div>
          `;
          
          // Add hover listener
          marker.addListener('mouseover', () => {
            const infoWindow = new google.maps.InfoWindow({
              content,
              position: { lat, lng }
            });
            infoWindow.open(map);
            
            // Close after 3 seconds or on mouseout
            setTimeout(() => infoWindow.close(), 3000);
            marker.addListener('mouseout', () => infoWindow.close());
          });
          
          newMarkers.push(marker);
        }
      });
    }
    
    setFlowMarkers(newMarkers);
    
    // Continue animation if still active
    if (isFlowAnimating) {
      animationFrameRef.current = requestAnimationFrame((newTimestamp) => 
        animateFlowPoints(newTimestamp, skipFactor));
    }
  }, [map, flowPoints, flowMarkers, isFlowAnimating, visualizationMode, getIntensityColor]);

  // Helper function to convert bearing to readable direction
  const getBearingAsDirection = useCallback((bearing: number) => {
    const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
    const index = Math.round(bearing / 45) % 8;
    return directions[index];
  }, []);

  // Restored function to update flow visualization
  const updateFlowVisualization = useCallback(async (timestamp: number) => {
    if (!map) return;
    
    // Guard against recursive updates
    if (updateStateRef.current.updating) {
      return;
    }
    
    updateStateRef.current.updating = true;
    setIsLoading(true);
    
    // Clear existing flow markers
    flowMarkers.forEach(marker => marker.setMap(null));
    flowPathsRef.current.forEach(path => path.setMap(null));
    
    try {
      // Get directions data from API (or cache)
      const directionsResults = await generateTrafficFlowData(
        map,
        selectedCity,
        timestamp,
        selectedTimeRange
      );
      
      if (directionsResults) {
        // Create polylines for each route if in flow or combined mode
        const polylines: google.maps.Polyline[] = [];
        
        if (visualizationMode === 'flow' || visualizationMode === 'combined') {
          directionsResults.forEach((result, index) => {
            if (!result.routes || !result.routes[0]) return;
            
            const route = result.routes[0];
            const path = route.overview_path;
            
            if (!path) return;
            
            // Create polyline for this route
            const polyline = new google.maps.Polyline({
              path,
              geodesic: true,
              strokeColor: getRouteColor(index),
              strokeOpacity: 0.8,
              strokeWeight: 3,
              map,
              icons: [{
                icon: {
                  path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
                  scale: 3,
                  strokeColor: '#ffffff'
                },
                offset: '0%',
                repeat: '80px'
              }]
            });
            
            // Add click listener for detailed stats
            polyline.addListener('click', () => {
              // Get stats for this route
              const stats = {
                distance: route.legs?.[0]?.distance?.text || 'Unknown',
                duration: route.legs?.[0]?.duration?.text || 'Unknown',
                startAddress: route.legs?.[0]?.start_address || 'Unknown',
                endAddress: route.legs?.[0]?.end_address || 'Unknown'
              };
              
              // Create info window
              const infoWindow = new google.maps.InfoWindow({
                content: `
                  <div class="stats-window">
                    <h3>Route Information</h3>
                    <p><strong>From:</strong> ${stats.startAddress}</p>
                    <p><strong>To:</strong> ${stats.endAddress}</p>
                    <p><strong>Distance:</strong> ${stats.distance}</p>
                    <p><strong>Duration:</strong> ${stats.duration}</p>
                  </div>
                `,
                position: path[Math.floor(path.length / 2)]
              });
              
              infoWindow.open(map);
            });
            
            polylines.push(polyline);
          });
        }
        
        // Store polylines in ref
        flowPathsRef.current = polylines;
        
        // Create flow points by extracting from each step
        const newFlowPoints: TrafficFlowPoint[] = [];
        let pointId = 0;
        
        // Determine skip factor based on zoom level for adaptive detail
        const zoomLevel = zoomLevelRef.current || 12;
        const skipFactor = Math.max(1, Math.floor(20 - zoomLevel));
        
        directionsResults.forEach((result, routeIndex) => {
          if (!result.routes || !result.routes[0] || !result.routes[0].legs) return;
          
          const leg = result.routes[0].legs[0];
          if (!leg || !leg.steps) return;
          
          // Calculate route intensity based on time of day and route popularity
          // This affects both density and color
          const date = new Date(timestamp);
          const hour = date.getHours();
          const dayOfWeek = date.getDay();
          const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
          
          // Intensity factor: higher during peak hours
          let intensityFactor = 1.0;
          if ((hour >= 7 && hour <= 9) || (hour >= 16 && hour <= 18)) {
            // Rush hours
            intensityFactor = isWeekend ? 1.2 : 1.8;
          } else if (hour >= 10 && hour <= 15) {
            // Mid-day
            intensityFactor = 1.3;
          } else if (hour >= 19 && hour <= 22) {
            // Evening
            intensityFactor = 1.4;
          } else {
            // Night
            intensityFactor = 0.6;
          }
          
          // Each step is a segment of the route
          leg.steps.forEach(step => {
            if (!step.path) return;
            
            // Get the path points for this segment
            const path = step.path;
            
            // Create points along the path
            for (let i = 0; i < path.length - 1; i += skipFactor) {
              const start = path[i];
              const end = path[i + 1];
              
              // Calculate direction
              const bearing = Math.atan2(
                end.lng() - start.lng(),
                end.lat() - start.lat()
              ) * 180 / Math.PI;
              
              // Calculate speed based on step duration and distance
              let speed = 1; // Default
              if (step.duration && step.distance) {
                // Convert to meters per second
                speed = step.distance.value / step.duration.value;
                
                // Normalize to 0.5-2 range for visualization
                speed = 0.5 + Math.min(1.5, speed / 10);
              }
              
              // Apply intensity factor to speed
              speed *= intensityFactor;
              
              // Create a flow point
              newFlowPoints.push({
                id: `flow-${routeIndex}-${pointId++}`,
                position: { lat: start.lat(), lng: start.lng() },
                nextPosition: { lat: end.lat(), lng: end.lng() },
                bearing: bearing,
                progress: Math.random(), // Stagger the starting positions
                routeIndex,
                speed: speed, // Normalized speed
                intensity: intensityFactor // Store intensity for color calculation
              });
            }
          });
        });
        
        // Set flow points for animation
        setFlowPoints(newFlowPoints);
        
        // Update heatmap if in heatmap or combined mode
        if (visualizationMode === 'heatmap' || visualizationMode === 'combined') {
          updateHeatmapFromFlowPoints(newFlowPoints);
        }
        
        // Show success toast if we haven't shown one recently
        const now = Date.now();
        if (!lastSuccessToastRef.current || (now - lastSuccessToastRef.current > 30000)) {
          toast.success('Routes loaded successfully!', { 
            duration: 3000,
            style: { background: '#10B981', color: '#fff' }
          });
          lastSuccessToastRef.current = now;
        }
        
        // Clear any error message
        setError(null);
      } else {
        // API data not available and we're not using simulated data
        // Just clear the visualization
        setFlowPoints([]);
        if (heatmap) {
          heatmap.setData([]);
        }
        
        // Show a detailed notification to the user
        toast.error(
          'Traffic data is unavailable. Please check that your Routes API key is valid and has sufficient quota.',
          {
            duration: 5000,
            style: {
              borderRadius: '8px',
              background: '#333',
              color: '#fff',
            },
          }
        );
        
        // Set a more informative error message
        setError('Routes API not returning data. Check your API key configuration and quotas in Google Cloud Console.');
      }
    } catch (error) {
      console.error('Error updating flow visualization:', error);
      setFlowPoints([]);
      if (heatmap) {
        heatmap.setData([]);
      }
      
      // Show a detailed error notification
      toast.error(
        `API Error: ${error instanceof Error ? error.message : 'Unknown error'}.`,
        {
          duration: 5000,
          style: {
            borderRadius: '8px',
            background: '#333',
            color: '#fff',
          },
        }
      );
      
      // Set error message
      setError(`Routes API error: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setIsLoading(false);
      updateStateRef.current.updating = false;
    }
  }, [
    map, 
    selectedCity, 
    selectedTimeRange, 
    visualizationMode, 
    flowMarkers, 
    heatmap, 
    updateHeatmapFromFlowPoints,
    setFlowPoints,
    setIsLoading
  ]);

  // Now we can define onLoad which depends on animateFlowPoints
  const onLoad = useCallback(function callback(map: google.maps.Map) {
    mapRef.current = map;
    setMap(map);
    
    // Configure map
    map.setCenter(selectedCity.center);
    map.setZoom(14);
    
    // Add zoom change listener for adaptive visualization
    map.addListener('zoom_changed', () => {
      const currentZoom = map.getZoom();
      if (currentZoom) {
        zoomLevelRef.current = currentZoom;
        // Update visualization density next time we render
        if (isFlowAnimating && flowPoints.length > 0) {
          // Cancel current animation frame if exists
          if (animationFrameRef.current) {
            cancelAnimationFrame(animationFrameRef.current);
          }
          
          // Restart animation with new density
          const skipFactor = Math.max(1, Math.floor(20 - currentZoom));
          animationFrameRef.current = requestAnimationFrame((timestamp) => 
            animateFlowPoints(timestamp, skipFactor));
        }
      }
    });
    
    // Add hover capabilities for areas to get more information
    map.addListener('mousemove', (e: google.maps.MapMouseEvent) => {
      if (e.latLng && flowPoints.length > 0) {
        const position = e.latLng;
        const nearbyPoints = findNearbyPoints(position, flowPoints, 50); // 50 meters radius
        
        if (nearbyPoints.length > 0) {
          setHoveredArea({
            position,
            data: {
              count: nearbyPoints.length,
              avgSpeed: calculateAverageSpeed(nearbyPoints),
              primaryDirection: calculatePrimaryDirection(nearbyPoints)
            }
          });
        } else {
          setHoveredArea(null);
        }
      }
    });
    
    // Create info window for place details
    infoWindowRef.current = new google.maps.InfoWindow();
    
    setIsMapInitialized(true);
  }, [selectedCity.center, animateFlowPoints, flowPoints, isFlowAnimating, findNearbyPoints, calculateAverageSpeed, calculatePrimaryDirection]);

  const onUnmount = useCallback(() => {
    mapRef.current = null;
    setMap(null);
  }, []);

  // Clean up markers and heatmap when component unmounts
  useEffect(() => {
    return () => {
      markers.forEach(marker => marker.setMap(null));
      flowMarkers.forEach(marker => marker.setMap(null));
      flowPathsRef.current.forEach(path => path.setMap(null));
      if (heatmap) {
        heatmap.setMap(null);
      }
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, [markers, heatmap, flowMarkers]);

  // When the city changes, update map and load new data
  useEffect(() => {
    if (!map || !isLoaded || !isMapInitialized) return;

    // Create a unique effect ID to avoid duplicate effects
    const effectId = `city-change-${selectedCity.name}`;
    
    // Clear existing markers
    markers.forEach(marker => marker.setMap(null));
    
    // Use a stable reference callback pattern for setState to avoid dependency loops
    setMarkers([]); // Clear markers first

    // Set map center to selected city with smooth animation
    map.panTo(selectedCity.center);
    map.setZoom(selectedCity.zoom);

    // Create cultural site markers for the selected city
    const culturalSites = SAMPLE_CULTURAL_SITES[selectedCity.name] || [];
    const newMarkers: google.maps.Marker[] = [];

    // Create markers for cultural sites
    culturalSites.forEach(site => {
      const marker = new google.maps.Marker({
        position: { lat: site.lat, lng: site.lng },
        map: map,
        title: site.name,
        icon: {
          url: 'https://maps.google.com/mapfiles/ms/icons/blue-dot.png'
        },
        animation: google.maps.Animation.DROP, // Add animation but only on initial load
        optimized: true // Improve performance
      });

      // Add click listener to marker
      marker.addListener('click', () => {
        if (infoWindowRef.current) {
          infoWindowRef.current.setContent(`
            <div>
              <h3>${site.name}</h3>
              <p>Estimated crowd density: ${Math.floor(Math.random() * 100)}%</p>
              <p>Day/Night visitor ratio: ${(0.5 + Math.random() * 0.8).toFixed(2)}</p>
            </div>
          `);
          infoWindowRef.current.open(map, marker);
        }
      });

      newMarkers.push(marker);
    });

    // Update markers state
    setMarkers(newMarkers);

    // Don't auto-fetch data for new city, wait for time range to be selected
    // to avoid multiple API calls

  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    isLoaded, 
    isMapInitialized,
    selectedCity.name, 
    selectedCity.center.lat, 
    selectedCity.center.lng, 
    selectedCity.zoom,
    // Exclude these from deps array to prevent loops:
    // map, heatmap, markers
  ]);

  // Show notification when time range changes
  useEffect(() => {
    // Don't show on initial load
    if (isMapInitialized) {
      setNotificationMessage(`Time range updated to: ${selectedTimeRange.label}`);
      setShowTimeRangeNotification(true);
      
      // Hide notification after 3 seconds
      const timer = setTimeout(() => {
        setShowTimeRangeNotification(false);
      }, 3000);
      
      return () => clearTimeout(timer);
    }
  }, [selectedTimeRange, isMapInitialized]);
  
  // Handle time range change
  useEffect(() => {
    if (!map || !isMapInitialized) return;

    // Clear heatmap when time range changes
    if (heatmap) {
      heatmap.setMap(null);
    }
    
    // Show loading state
    setIsLoading(true);
    setError(null);
    
    // Cache key for this city and time range combination
    const cacheKey = `${selectedCity.name}-${selectedTimeRange.id}-${selectedTimeRange.value}`;
    
    // Function to create heatmap from data
    const createHeatmap = (data: google.maps.visualization.WeightedLocation[]) => {
      const newHeatmap = new google.maps.visualization.HeatmapLayer({
        data: data,
        map: map,
        radius: 20,
        opacity: 0.7,
        gradient: [
          'rgba(0, 255, 255, 0)',
          'rgba(0, 255, 255, 1)',
          'rgba(0, 191, 255, 1)',
          'rgba(0, 127, 255, 1)',
          'rgba(0, 63, 255, 1)',
          'rgba(0, 0, 255, 1)',
          'rgba(0, 0, 223, 1)',
          'rgba(0, 0, 191, 1)',
          'rgba(0, 0, 159, 1)',
          'rgba(0, 0, 127, 1)',
          'rgba(63, 0, 91, 1)',
          'rgba(127, 0, 63, 1)',
          'rgba(191, 0, 31, 1)',
          'rgba(255, 0, 0, 1)'
        ]
      });
      
      // Update heatmap state
      setHeatmap(newHeatmap);
      heatmapDataRef.current = data;
      setIsLoading(false);
    };
    
    // Check if we have cached data
    if (timeRangeDataCache.current[cacheKey]) {
      // Use cached data
      createHeatmap(timeRangeDataCache.current[cacheKey]);
    } else {
      // Fetch new data
      fetchDataForTimeRange(map, selectedCity.center, selectedTimeRange)
        .then(data => {
          // Cache the data
          timeRangeDataCache.current[cacheKey] = data;
          createHeatmap(data);
        })
        .catch(err => {
          console.error('Error fetching data for time range:', err);
          setError('Failed to fetch place data. Please try again.');
          setIsLoading(false);
        });
    }
    
  }, [map, isMapInitialized, selectedTimeRange, selectedCity.center.lat, selectedCity.center.lng, selectedCity.name]);

  // Use a single ref to track all update-related information 
  const updateStateRef = useRef({
    needsUpdate: true,
    updating: false,
    lastUpdateTimestamp: 0,
    initialized: false
  });

  // Update visualization when timestamp changes significantly
  useEffect(() => {
    if (!map || !isMapInitialized) return;
    
    // Skip if already updating
    if (updateStateRef.current.updating) return;
    
    // Only update on significant time changes
    const needsUpdate = (() => {
      // If no previous update, update anyway
      if (updateStateRef.current.lastUpdateTimestamp === 0) {
        return true;
      }
      
      // Check if time changed significantly (10+ minutes)
      if (currentTimestamp) {
        const lastUpdate = updateStateRef.current.lastUpdateTimestamp;
        const timeDifference = Math.abs(currentTimestamp - lastUpdate);
        return timeDifference > 600000; // 10 minutes in milliseconds
      }
      
      return false;
    })();
    
    // If we need an update, trigger it once
    if (needsUpdate) {
      // Store the current timestamp to prevent multiple updates
      const timestamp = currentTimestamp || new Date().getTime();
      
      // Store timestamp in ref immediately to prevent subsequent updates
      updateStateRef.current.lastUpdateTimestamp = timestamp;
      
      // Dispatch update as a callback to avoid setState during render
      setTimeout(() => {
        if (!updateStateRef.current.updating) {
          updateFlowVisualization(timestamp);
        }
      }, 0);
    }
    
    // Adjust heatmap opacity based on time of day
    if (heatmap && currentTimestamp) {
      const date = new Date(currentTimestamp);
      const hour = date.getHours();
      const dayOfWeek = date.getDay(); // 0 = Sunday, 6 = Saturday
      const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
      
      // Lower opacity at night, higher during peak hours
      let opacity = 0.7; // default
      
      if (hour >= 22 || hour < 6) {
        // Night time (10pm - 6am)
        opacity = isWeekend ? 0.5 : 0.3;
      } else if ((hour >= 7 && hour <= 9) || (hour >= 16 && hour <= 18)) {
        // Rush hours (7-9am, 4-6pm)
        opacity = isWeekend ? 0.7 : 0.9;
      } else if (hour >= 12 && hour <= 14) {
        // Lunch time
        opacity = 0.8;
      }
      
      // Update heatmap opacity
      heatmap.set('opacity', opacity);
    }
  }, [map, isMapInitialized, currentTimestamp, heatmap, updateFlowVisualization]);

  // Ref to track previous time range for detecting changes
  const prevTimeRangeRef = useRef<TimeRange>(selectedTimeRange);
  
  // Create a separate effect to handle selectedTimeRange changes
  useEffect(() => {
    if (map && isMapInitialized) {
      // Check if time range has actually changed to avoid unnecessary updates
      if (
        prevTimeRangeRef.current.value !== selectedTimeRange.value ||
        prevTimeRangeRef.current.label !== selectedTimeRange.label
      ) {
        // Update the ref immediately
        prevTimeRangeRef.current = selectedTimeRange;
        
        // Use setTimeout to avoid setState during render
        setTimeout(() => {
          if (!updateStateRef.current.updating) {
            updateFlowVisualization(currentTimestamp || new Date().getTime());
          }
        }, 0);
      }
    }
  }, [selectedTimeRange, map, isMapInitialized, currentTimestamp, updateFlowVisualization]);
  
  // Start/stop flow animation based on shouldAnimateHeatmap prop
  useEffect(() => {
    // Start animation when play button is pressed
    if (shouldAnimateHeatmap && map && flowPoints.length > 0) {
      setIsFlowAnimating(true);
      
      // Start animation loop
      animationFrameRef.current = requestAnimationFrame((timestamp) => 
        animateFlowPoints(timestamp, 1));
    } else {
      // Stop animation
      setIsFlowAnimating(false);
      
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
      
      // Clear last timestamp
      lastTimestampRef.current = null;
    }
    
    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, [shouldAnimateHeatmap, map, flowPoints, animateFlowPoints]);

  // Handle map click to fetch real-time data
  const handleMapClick = async (e: google.maps.MapMouseEvent) => {
    if (!map || !e.latLng) return;
    
    try {
      // Show the info window with loading message
      if (infoWindowRef.current) {
        infoWindowRef.current.setContent('<div>Loading place information...</div>');
        infoWindowRef.current.setPosition(e.latLng);
        infoWindowRef.current.open(map);
      }
      
      // Try to get place details for the clicked location
      const placeDetails = await fetchPlaceDetails(map, e.latLng);
      
      if (placeDetails) {
        // Format the place details for display
        const content = `
          <div>
            <h3>${placeDetails.name || 'Unnamed Location'}</h3>
            ${placeDetails.formatted_address ? `<p>${placeDetails.formatted_address}</p>` : ''}
            ${placeDetails.rating ? `<p>Rating: ${placeDetails.rating} (${placeDetails.user_ratings_total} reviews)</p>` : ''}
            ${placeDetails.types ? `<p>Type: ${placeDetails.types[0].replace(/_/g, ' ')}</p>` : ''}
            <p>Estimated crowd levels vary by time of day</p>
          </div>
        `;
        
        if (infoWindowRef.current) {
          infoWindowRef.current.setContent(content);
        }
      } else {
        // No place found, show generic area information
        const areaName = `Area near ${e.latLng.lat().toFixed(5)}, ${e.latLng.lng().toFixed(5)}`;
        
        if (infoWindowRef.current) {
          infoWindowRef.current.setContent(`
            <div>
              <h3>${areaName}</h3>
              <p>No specific place information available for this location.</p>
              <p>Try clicking near points of interest for more details.</p>
            </div>
          `);
        }
    } catch (error) {
      console.error('Error handling map click:', error);
      
      if (infoWindowRef.current) {
        infoWindowRef.current.setContent(`
          <div>
            <h3>Error</h3>
            <p>Unable to fetch information for this location.</p>
            <p>This could be due to Places API limitations or network issues.</p>
          </div>
        `);
      }
    }
  };

  // Toggle visualization mode function
  const toggleVisualizationMode = useCallback((mode: 'heatmap' | 'flow' | 'combined') => {
    setVisualizationMode(mode);
    
    // Update heatmap and flow visualization based on new mode
    if (heatmap) {
      setTimeout(() => {
        // We use setTimeout to ensure state update has happened
        heatmap.setMap(
          visualizationMode === 'heatmap' || visualizationMode === 'combined' 
            ? map 
            : null
        );
        
        if (visualizationMode === 'flow' || visualizationMode === 'combined') {
          // Update flow markers for next frame
          if (animationFrameRef.current) {
            cancelAnimationFrame(animationFrameRef.current);
          }
          
          if (isFlowAnimating) {
            const skipFactor = Math.max(1, Math.floor(20 - (zoomLevelRef.current || 12)));
            animationFrameRef.current = requestAnimationFrame((timestamp) => 
              animateFlowPoints(timestamp, skipFactor));
          }
        } else {
          // Clear flow markers if not showing flow
          flowMarkers.forEach(marker => marker.setMap(null));
          setFlowMarkers([]);
        }
      }, 0);
    }
  }, [visualizationMode, heatmap, map, animateFlowPoints, isFlowAnimating, flowMarkers]);

  // Initialize visualization when map first loads
  useEffect(() => {
    if (map && isMapInitialized && !updateStateRef.current.initialized) {
      updateStateRef.current.initialized = true;
      
      // Initial visualization setup based on current timestamp
      updateFlowVisualization(currentTimestamp || new Date().getTime());
      
      // Add listener for visualization mode change
      map.addListener('zoom_changed', () => {
        const currentZoom = map.getZoom();
        if (currentZoom) {
          zoomLevelRef.current = currentZoom;
        }
      });
    }
  }, [map, isMapInitialized, updateFlowVisualization, currentTimestamp]);

  // Update visualization when visualization mode changes
  useEffect(() => {
    if (map && heatmap) {
      // Toggle heatmap visibility based on visualization mode
      heatmap.setMap(
        visualizationMode === 'heatmap' || visualizationMode === 'combined' 
          ? map 
          : null
      );
      
      // If flow points exist, update their visualization
      if (flowPoints.length > 0) {
        // For flow mode, make sure we have flow markers
        if (visualizationMode === 'flow' || visualizationMode === 'combined') {
          // Clear and recreate flow markers
          flowMarkers.forEach(marker => marker.setMap(null));
          
          // Restart animation if it's active
          if (isFlowAnimating) {
            if (animationFrameRef.current) {
              cancelAnimationFrame(animationFrameRef.current);
            }
            
            const skipFactor = Math.max(1, Math.floor(20 - (zoomLevelRef.current || 12)));
            animationFrameRef.current = requestAnimationFrame((timestamp) => 
              animateFlowPoints(timestamp, skipFactor));
          }
        } else {
          // Clear flow markers if not showing flow
          flowMarkers.forEach(marker => marker.setMap(null));
          setFlowMarkers([]);
        }
        
        // Make sure polylines visibility matches visualization mode
        flowPathsRef.current.forEach(polyline => {
          polyline.setMap(
            visualizationMode === 'flow' || visualizationMode === 'combined' 
              ? map 
              : null
          );
        });
      }
    }
  }, [visualizationMode, map, heatmap, flowPoints.length, flowMarkers, isFlowAnimating, animateFlowPoints]);

  // Add a link to open Google Cloud billing console
  const openGoogleCloudBilling = () => {
    window.open('https://console.cloud.google.com/billing', '_blank');
  };

  // Add a link to check API specific quota and billing
  const openRoutesAPIPage = () => {
    window.open('https://console.cloud.google.com/apis/api/routes.googleapis.com/overview', '_blank');
  };

  // Add helper for general troubleshooting page
  const openAPITroubleshooting = () => {
    window.open('https://developers.google.com/maps/documentation/javascript/error-messages', '_blank');
  };

  // Add a function to check API availability
  const checkApiAvailability = useCallback(async () => {
    if (!map) {
      toast.error('Map not initialized yet.');
      return;
    }
    
    setIsLoading(true);
    
    try {
      // Check if the Google Maps API is fully loaded
      if (typeof google === 'undefined') {
        console.error('Google Maps API is not loaded');
        toast.error('Google Maps API is not loaded yet. Please try again in a moment.');
        setIsLoading(false);
        return;
      }
      
      // Check for specific APIs
      console.log('--- GOOGLE MAPS API AVAILABILITY CHECK ---');
      const apiStatus = {
        main: !!google,
        maps: !!google.maps,
        routes: !!google.maps.routes,
        routesService: !!google.maps.routes?.RoutesService,
        places: !!google.maps.places,
        visualization: !!google.maps.visualization,
        geometry: !!google.maps.geometry,
        version: google.maps.version || 'unknown'
      };
      
      console.log('API Status:', apiStatus);
      
      // Use standard toast
      toast('Checking Routes API connectivity...', { 
        duration: 3000,
        style: {
          background: '#3498db',
          color: '#fff',
        },
        icon: 'üîç'
      });
      
      // First display the API status in a toast
      let statusMessage = 'API Status:\n';
      Object.entries(apiStatus).forEach(([key, value]) => {
        statusMessage += `‚Ä¢ ${key}: ${value ? '‚úÖ' : '‚ùå'}\n`;
      });
      
      // Show API status toast
      toast(statusMessage, {
        duration: 8000,
        style: {
          background: '#f0f9ff',
          color: '#333',
          whiteSpace: 'pre-line',
          padding: '12px',
        },
      });
      
      // Test a simple route request
      const testOrigin = selectedCity.center;
      const testDestination = {
        lat: testOrigin.lat + 0.02,
        lng: testOrigin.lng + 0.02
      };
      
      // Log API check information
      console.log('Testing with coordinates:', {
        origin: testOrigin,
        destination: testDestination
      });
      
      if (apiStatus.routes && apiStatus.routesService) {
        // Test Routes API
        try {
          const routesService = new google.maps.routes.RoutesService();
          const request = {
            origin: {
              location: {
                latLng: {
                  latitude: testOrigin.lat,
                  longitude: testOrigin.lng
                }
              }
            },
            destination: {
              location: {
                latLng: {
                  latitude: testDestination.lat,
                  longitude: testDestination.lng
                }
              }
            },
            travelMode: google.maps.routes.TravelMode.DRIVE,
          };
          
          toast('Making Routes API test request...', {
            duration: 2000,
            style: { background: '#3498db', color: '#fff' }
          });
          
          const response = await new Promise((resolve, reject) => {
            routesService.computeRoute(request, (result, status) => {
              console.log('Routes API test status:', status);
              if (status === 200) {
                resolve(result);
              } else {
                reject(new Error(`Status: ${status}`));
              }
            });
          });
          
          console.log('Routes API test successful!', response);
          toast.success('Routes API is working correctly!', { duration: 5000 });
        } catch (error) {
          console.error('Routes API test failed:', error);
          
          // Check for error types commonly associated with billing issues
          const errorMsg = error instanceof Error ? error.message : 'Unknown error';
          const isBillingError = errorMsg.includes('RESOURCE_EXHAUSTED') || 
                               errorMsg.includes('billing') || 
                               errorMsg.includes('quota') || 
                               errorMsg.includes('PERMISSION_DENIED');
          
          // Show specific error message depending on the likely cause
          const errorToast = isBillingError 
            ? 'Routes API failed with a billing or quota error. Click below to check your billing status.'
            : `Routes API test failed: ${errorMsg}`;
          
          // Show detailed troubleshooting information
          toast(errorToast, {
            duration: 10000,
            style: { 
              background: '#fef2f2', 
              color: '#b91c1c', 
              padding: '16px',
              borderRadius: '8px' 
            },
            icon: '‚ùå',
          });
          
          // If it's likely a billing issue, show specific billing check action
          if (isBillingError) {
            setTimeout(() => {
              toast((t) => (
                <div onClick={() => openGoogleCloudBilling()}>
                  <div style={{ fontWeight: 'bold', marginBottom: '6px' }}>Check Google Cloud Billing</div>
                  <div style={{ fontSize: '14px' }}>
                    Click here to open the billing console and verify your billing is properly set up.
                  </div>
                </div>
              ), { 
                duration: 15000, 
                style: { 
                  background: '#fff',
                  color: '#333',
                  padding: '16px',
                  borderRadius: '8px',
                  cursor: 'pointer'
                }
              });
            }, 1000);
          } else {
            // Show general troubleshooting steps
            setTimeout(() => {
              toast(
                '1. Make sure the Routes API is enabled in Google Cloud Console\n' +
                '2. Check if your API key has billing enabled\n' +
                '3. Verify your API key doesn\'t have restrictions\n' +
                '4. Try creating a new API key for testing',
                {
                  duration: 10000,
                  style: {
                    background: '#fff',
                    color: '#333',
                    whiteSpace: 'pre-line',
                    padding: '12px',
                    boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
                  },
                  icon: 'üí°',
                }
              );
            }, 1000);
          }
        }
      } else {
        // Routes API not available
        console.error('Routes API is not available');
        
        // First, show the error
        toast.error('Routes API is not available in the Maps JavaScript API', { duration: 5000 });
        
        // Then show detailed troubleshooting steps with clickable buttons
        setTimeout(() => {
          toast(
            (t) => (
              <div>
                <div style={{ fontWeight: 'bold', marginBottom: '10px' }}>Routes API Not Available</div>
                <div style={{ marginBottom: '15px' }}>
                  The Routes API is enabled in your Google Cloud Console, but it's not loading correctly in your application.
                </div>
                <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                  <button 
                    onClick={() => openRoutesAPIPage()} 
                    style={{ 
                      padding: '8px', 
                      backgroundColor: '#4285F4', 
                      color: 'white', 
                      border: 'none', 
                      borderRadius: '4px',
                      cursor: 'pointer'
                    }}
                  >
                    Check Routes API Status
                  </button>
                  <button 
                    onClick={() => openGoogleCloudBilling()} 
                    style={{ 
                      padding: '8px', 
                      backgroundColor: '#34A853', 
                      color: 'white', 
                      border: 'none', 
                      borderRadius: '4px',
                      cursor: 'pointer'
                    }}
                  >
                    Verify Billing Setup
                  </button>
                  <button 
                    onClick={() => openAPITroubleshooting()} 
                    style={{ 
                      padding: '8px', 
                      backgroundColor: '#EA4335', 
                      color: 'white', 
                      border: 'none', 
                      borderRadius: '4px',
                      cursor: 'pointer'
                    }}
                  >
                    Error Troubleshooting Guide
                  </button>
                </div>
              </div>
            ),
            {
              duration: 20000,
              style: {
                background: '#fff',
                color: '#333',
                padding: '16px',
                boxShadow: '0 4px 8px rgba(0,0,0,0.1)',
                maxWidth: '400px',
              },
            }
          );
        }, 1000);
      }
    } catch (error) {
      console.error('API check error:', error);
      toast.error(`API check error: ${error instanceof Error ? error.message : JSON.stringify(error)}`, { duration: 5000 });
    } finally {
      setIsLoading(false);
    }
  }, [map, selectedCity]);

  // Add an effect to check for Routes API availability after the map loads
  useEffect(() => {
    if (map && isMapInitialized) {
      const routesAvailable = isRoutesApiAvailable();
      if (!routesAvailable) {
        console.error("Routes API is not available in Google Maps");
        setError('Routes API is not available. Please make sure you have enabled the Routes API in your Google Cloud Console.');
        
        // Show a toast with troubleshooting info
        toast(
          'Routes API not available. Click "Check API" for diagnostics.',
          {
            duration: 5000,
            style: {
              background: '#fef2f2',
              color: '#b91c1c',
              borderLeft: '4px solid #b91c1c',
              padding: '12px',
            },
            icon: '‚ö†Ô∏è',
          }
        );
      }
    }
  }, [map, isMapInitialized]);

  // Add a function to test the Routes API directly via REST
  const testDirectRoutesAPI = useCallback(async () => {
    setIsLoading(true);
    
    try {
      toast('Testing direct Routes API call...', {
        duration: 3000,
        style: { background: '#3498db', color: '#fff' }
      });
      
      const testOrigin = selectedCity.center;
      const testDestination = {
        lat: testOrigin.lat + 0.02,
        lng: testOrigin.lng + 0.02
      };
      
      // Create a request body for the REST API
      const requestBody = {
        origin: {
          location: {
            latLng: {
              latitude: testOrigin.lat,
              longitude: testOrigin.lng
            }
          }
        },
        destination: {
          location: {
            latLng: {
              latitude: testDestination.lat,
              longitude: testDestination.lng
            }
          }
        },
        travelMode: "DRIVE",
        routingPreference: "TRAFFIC_AWARE",
        computeAlternativeRoutes: false,
        languageCode: "en-US",
        units: "IMPERIAL"
      };
      
      // Make a direct REST API call to the Routes API
      const response = await fetch(
        'https://routes.googleapis.com/directions/v2:computeRoutes', 
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Goog-Api-Key': process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY || '',
            'X-Goog-FieldMask': '*'
          },
          body: JSON.stringify(requestBody)
        }
      );
      
      console.log('Direct Routes API status:', response.status);
      
      if (response.ok) {
        const data = await response.json();
        console.log('Direct Routes API success:', data);
        
        toast.success('Direct Routes API call successful!', { 
          duration: 5000,
          style: { background: '#10B981', color: '#fff', padding: '16px' }
        });
        
        // Show some details from the response
        setTimeout(() => {
          if (data && data.route) {
            toast(
              `Route found: ${(data.route.distanceMeters / 1609.34).toFixed(1)} miles, ${data.route.duration}`,
              {
                duration: 8000,
                style: {
                  background: '#f0f9ff',
                  color: '#333',
                  padding: '12px',
                }
              }
            );
          }
        }, 1000);
        
        return data;
      } else {
        const errorText = await response.text();
        console.error('Direct Routes API failed:', response.status, errorText);
        
        toast.error(`Direct Routes API failed: ${response.status}`, { 
          duration: 5000,
          style: { background: '#EF4444', color: '#fff', padding: '16px' }
        });
        
        // Show error details
        setTimeout(() => {
          toast(
            `Error Details:\n${errorText}`,
            {
              duration: 10000,
              style: {
                background: '#fff',
                color: '#333',
                whiteSpace: 'pre-line',
                padding: '12px',
              },
              icon: '‚ö†Ô∏è',
            }
          );
        }, 1000);
        
        return null;
      }
    } catch (error) {
      console.error('Error making direct Routes API call:', error);
      toast.error(`Error making direct Routes API call: ${error instanceof Error ? error.message : 'Unknown error'}`, { 
        duration: 5000
      });
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [selectedCity, process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY]);

  // Add a function to force refresh traffic data
  const forceRefreshTrafficData = useCallback(() => {
    // Set global flag to force refresh
    (window as any).__forceRefreshTrafficData = true;
    
    // Show toast to indicate refresh
    toast('Forcing fresh traffic data...', {
      duration: 3000,
      style: { background: '#4B5563', color: '#fff' }
    });
    
    // Clear any error messages
    setError(null);
    
    // Update flow visualization with current timestamp
    setTimeout(() => {
      updateFlowVisualization(currentTimestamp || new Date().getTime());
    }, 100);
  }, [currentTimestamp, updateFlowVisualization]);

  // Add a diagnostics display function
  const showApiDiagnostics = useCallback(() => {
    // Format timestamps
    const formatTime = (timestamp: number) => {
      if (!timestamp) return 'Never';
      return new Date(timestamp).toLocaleTimeString();
    };
    
    // Create diagnostic status report
    const diagnostics = {
      lastCallTime: formatTime(apiDiagnostics.lastApiCallTime),
      successfulCalls: apiDiagnostics.successfulCalls,
      failedCalls: apiDiagnostics.failedCalls,
      lastSuccess: apiDiagnostics.lastApiCallSuccess ? 'Yes' : 'No',
      lastError: apiDiagnostics.lastError ? apiDiagnostics.lastError.message : 'None',
      routesApiAvailable: isRoutesApiAvailable() ? 'Yes' : 'No',
      lastSuccessfulRequest: apiDiagnostics.lastSuccessfulRequest ? 
        JSON.stringify(apiDiagnostics.lastSuccessfulRequest.response, null, 2) : 'None'
    };
    
    // Show diagnostics in a toast
    toast(
      (t) => (
        <div>
          <h3 className="font-bold mb-2 text-lg">API Diagnostics</h3>
          <div className="text-sm space-y-1 mb-3">
            <p><strong>Last API Call:</strong> {diagnostics.lastCallTime}</p>
            <p><strong>Success/Fail Count:</strong> {diagnostics.successfulCalls}/{diagnostics.failedCalls}</p>
            <p><strong>Last Call Success:</strong> {diagnostics.lastSuccess}</p>
            <p><strong>Routes API Available:</strong> {diagnostics.routesApiAvailable}</p>
            {diagnostics.lastError !== 'None' && (
              <p className="text-red-500"><strong>Last Error:</strong> {diagnostics.lastError}</p>
            )}
          </div>
          <div className="flex space-x-2">
            <button
              onClick={() => {
                apiDiagnostics.clearCache();
                toast.dismiss(t.id);
                toast.success('Cache cleared!', { duration: 2000 });
              }}
              className="bg-red-500 text-white px-3 py-1 rounded text-sm"
            >
              Clear Cache
            </button>
            <button
              onClick={() => toast.dismiss(t.id)}
              className="bg-gray-500 text-white px-3 py-1 rounded text-sm"
            >
              Close
            </button>
            <button
              onClick={() => {
                forceRefreshTrafficData();
                toast.dismiss(t.id);
              }}
              className="bg-blue-500 text-white px-3 py-1 rounded text-sm"
            >
              Force Refresh
            </button>
          </div>
        </div>
      ),
      {
        duration: 15000,
        style: {
          maxWidth: '100%',
          width: '400px',
          background: '#fff',
          color: '#000',
          padding: '16px',
        },
      }
    );
  }, [forceRefreshTrafficData]);

  // Add a function to view raw route responses
  const viewRawResponses = useCallback(() => {
    const responses = apiDiagnostics.routeResponses || [];
    
    if (responses.length === 0) {
      toast.error('No API responses have been recorded yet');
      return;
    }
    
    // Create code blocks for each response
    const responsesText = responses.map((resp, idx) => {
      try {
        // Try to parse and prettify the JSON
        const parsed = JSON.parse(resp.rawData);
        const prettyJson = JSON.stringify(parsed, null, 2);
        
        return `--- Response #${resp.requestNumber} (${new Date(resp.timestamp).toLocaleTimeString()}) ---\n${prettyJson}\n\n`;
      } catch (e) {
        return `--- Response #${resp.requestNumber} (${new Date(resp.timestamp).toLocaleTimeString()}) ---\n${resp.rawData}\n\n`;
      }
    }).join('\n');
    
    // Create a modal-like overlay for viewing the raw data
    const overlay = document.createElement('div');
    overlay.style.position = 'fixed';
    overlay.style.top = '0';
    overlay.style.left = '0';
    overlay.style.width = '100%';
    overlay.style.height = '100%';
    overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
    overlay.style.zIndex = '9999';
    overlay.style.display = 'flex';
    overlay.style.justifyContent = 'center';
    overlay.style.alignItems = 'center';
    overlay.style.padding = '20px';
    
    // Create the modal content
    const content = document.createElement('div');
    content.style.backgroundColor = 'white';
    content.style.borderRadius = '8px';
    content.style.maxWidth = '90%';
    content.style.maxHeight = '90%';
    content.style.overflow = 'auto';
    content.style.padding = '20px';
    content.style.position = 'relative';
    
    // Add a close button
    const closeButton = document.createElement('button');
    closeButton.innerText = 'Close';
    closeButton.style.position = 'sticky';
    closeButton.style.top = '0';
    closeButton.style.right = '0';
    closeButton.style.backgroundColor = '#e53e3e';
    closeButton.style.color = 'white';
    closeButton.style.border = 'none';
    closeButton.style.borderRadius = '4px';
    closeButton.style.padding = '8px 16px';
    closeButton.style.margin = '0 0 10px auto';
    closeButton.style.display = 'block';
    closeButton.style.cursor = 'pointer';
    closeButton.onclick = () => document.body.removeChild(overlay);
    
    // Add a title
    const title = document.createElement('h2');
    title.innerText = `Raw API Responses (${responses.length})`;
    title.style.marginBottom = '16px';
    
    // Add the response data
    const pre = document.createElement('pre');
    pre.style.whiteSpace = 'pre-wrap';
    pre.style.fontSize = '14px';
    pre.style.backgroundColor = '#f5f5f5';
    pre.style.padding = '12px';
    pre.style.borderRadius = '4px';
    pre.style.overflow = 'auto';
    pre.innerText = responsesText;
    
    // Assemble the components
    content.appendChild(closeButton);
    content.appendChild(title);
    content.appendChild(pre);
    overlay.appendChild(content);
    
    // Add to body
    document.body.appendChild(overlay);
    
    // Also log to console for easy copying
    console.log('Raw API Responses:', responses);
  }, []);

  // Update the renderApiTestButtons to include the new buttons
  const renderApiTestButtons = () => (
    <div className="absolute top-4 right-4 z-10 flex flex-col space-y-2">
      <div className="flex space-x-2">
        <button
          onClick={checkApiAvailability}
          className="bg-blue-600 text-white text-sm px-3 py-1 rounded shadow-md hover:bg-blue-700 transition-colors"
        >
          Check API
        </button>
        <button
          onClick={testDirectRoutesAPI}
          className="bg-green-600 text-white text-sm px-3 py-1 rounded shadow-md hover:bg-green-700 transition-colors"
        >
          Direct API Test
        </button>
      </div>
      <div className="flex space-x-2">
        <button
          onClick={showApiDiagnostics}
          className="bg-purple-600 text-white text-sm px-3 py-1 rounded shadow-md hover:bg-purple-700 transition-colors"
        >
          Show Diagnostics
        </button>
        <button
          onClick={forceRefreshTrafficData}
          className="bg-yellow-600 text-white text-sm px-3 py-1 rounded shadow-md hover:bg-yellow-700 transition-colors"
        >
          Force Refresh
        </button>
      </div>
      <div className="flex space-x-2">
        <button
          onClick={viewRawResponses}
          className="bg-indigo-600 text-white text-sm px-3 py-1 rounded shadow-md hover:bg-indigo-700 transition-colors"
        >
          View Raw Responses
        </button>
      </div>
    </div>
  );

  // Add an effect to pass flow points to parent component
  useEffect(() => {
    if (onFlowPointsUpdate && flowPoints.length > 0) {
      onFlowPointsUpdate(flowPoints);
    }
  }, [flowPoints, onFlowPointsUpdate]);

  // Add function to fetch and pass nearby places to parent component
  const fetchAndPassNearbyPlaces = useCallback(async () => {
    if (!map || !onNearbyPlacesUpdate) return;
    
    try {
      const places = await fetchNearbyPlaces(
        map, 
        selectedCity.center, 
        2500, 
        'tourist_attraction',
        ['transit_station', 'shopping_mall', 'restaurant', 'park']
      );
      
      onNearbyPlacesUpdate(places);
    } catch (error) {
      console.error('Error fetching nearby places:', error);
    }
  }, [map, selectedCity.center, onNearbyPlacesUpdate]);
  
  // Call fetch places when city changes
  useEffect(() => {
    if (map && isMapInitialized && onNearbyPlacesUpdate) {
      fetchAndPassNearbyPlaces();
    }
  }, [selectedCity, map, isMapInitialized, fetchAndPassNearbyPlaces, onNearbyPlacesUpdate]);

  return (
    <div className="relative w-full h-full">
      {/* Loading indicator */}
      {isLoading && (
        <div className="absolute top-4 left-1/2 transform -translate-x-1/2 bg-white py-2 px-4 rounded-md shadow-md z-10">
          <p className="flex items-center">
            <span className="animate-spin rounded-full h-4 w-4 border-b-2 border-gray-900 mr-2"></span>
            Loading traffic data...
          </p>
        </div>
      )}
      
      {/* Error message */}
      {error && (
        <div className="absolute top-4 left-1/2 transform -translate-x-1/2 bg-red-100 border border-red-400 text-red-700 py-2 px-4 rounded-md shadow-md z-10">
          <p>{error}</p>
        </div>
      )}

      {/* Display loading message if the API hasn't loaded yet */}
      {!isLoaded ? (
        <div className="w-full h-full flex items-center justify-center bg-gray-100">
          <div className="text-center">
            <div className="animate-spin rounded-full h-10 w-10 border-4 border-blue-500 border-t-transparent mx-auto mb-4"></div>
            <p className="text-gray-700">Loading Google Maps...</p>
          </div>
        </div>
      ) : loadError ? (
        <div className="w-full h-full flex items-center justify-center bg-gray-100">
          <div className="text-center text-red-600 max-w-md p-4">
            <p className="text-xl font-bold mb-2">Error Loading Google Maps</p>
            <p>{loadError.message || "Failed to load Google Maps. Please check your API key and network connection."}</p>
          </div>
        </div>
      ) : (
        <>
          {/* Visualization mode toggle buttons */}
          <div className="absolute bottom-4 left-4 bg-white rounded-md shadow-md z-10 overflow-hidden">
            <div className="flex">
              <button
                className={`px-3 py-2 text-sm ${visualizationMode === 'heatmap' ? 'bg-blue-500 text-white' : 'bg-white text-gray-700'}`}
                onClick={() => toggleVisualizationMode('heatmap')}
              >
                Heatmap
              </button>
              <button
                className={`px-3 py-2 text-sm ${visualizationMode === 'flow' ? 'bg-blue-500 text-white' : 'bg-white text-gray-700'}`}
                onClick={() => toggleVisualizationMode('flow')}
              >
                Flow
              </button>
              <button
                className={`px-3 py-2 text-sm ${visualizationMode === 'combined' ? 'bg-blue-500 text-white' : 'bg-white text-gray-700'}`}
                onClick={() => toggleVisualizationMode('combined')}
              >
                Combined
              </button>
            </div>
          </div>

          {/* API Check Button */}
          {renderApiTestButtons()}

          {/* Google Map */}
          <GoogleMap
            mapContainerStyle={containerStyle}
            center={selectedCity.center}
            zoom={12}
            options={mapOptions}
            onLoad={onLoad}
            onUnmount={onUnmount}
          />
        </>
      )}
    </div>
  );
};

export default Map; 